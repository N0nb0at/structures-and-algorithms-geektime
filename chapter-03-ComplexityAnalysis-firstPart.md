---
title: 数据结构与算法-03-复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
date: 2019/04-18 21:42:49
categories:
  - [Structures & Algorithms]
tags:
  - [Structures & Algorithms]
  - [Stack]
---

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

## 为什么需要复杂度分析？

将代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。很多数据结构和算法书记将这种方法起名为**事后统计法**。这种方法有非常大的局限性：

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

所以，我们需要一个不用具体测试数据来测试，就可以粗略地估计算法的执行效率的方法：时间、空间复杂度分析方法。

## 大 O 复杂度表示法

所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

$$ T(n)=O(f(n)). $$

其中，T(n) 表示代码的执行时间；n 表示数据规模大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

这就是**大 O 时间复杂度表示法**。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫做**渐进时间复杂度（asymptotic time complexity）** ，简称**时间复杂度**。

当 n 很大时，可以把它想象成 10000、1000000。而公式中的低阶、常量、系数三部分并不左右增长的趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如果用大 O 表示法表示，就可以记为：$ T(n) = O(n); T(n) = O(n^2) $。

## 时间复杂度分析

### 只关注循环执行次数最多的一段代码

大 O 复杂度表示法只是表示一种变化趋势。我们通常会忽略掉公式的常量、低阶、系数，值记录一个最大阶的量级就可以了。所以，**我们在分析一个算法、一段代码的时间复杂度时，也只关注循环执行次数最多的那一段代码就可以了**。这段核心代码执行次数 n 的量级，就是整段要分析代码的时间复杂度。

### 加法法则：总复杂度等于量级最大的那段代码的复杂度

如果 $ T1(n) = O(f(n)), T2(n) = O(g(n)) $，那么 $ T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n))). $。

### 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

如果 $ T1(n) = O(f(n)), T2(n) = O(g(n)) $，那么 $ T(n) = T1(n) * T2(n) = O(f(n) * O(g(n)) = O(f(n) * g(n)). $。也就是说假设 $ T1(n) = O(n), T2(n) = O(n^2) $，则 $ T(n) = O(n^3). $。

## 几种常见时间复杂度实例分析

对于刚罗列的复杂度量级，我们可以粗略地分为两类：**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个， $ O(2^n) $ 和 $ O(n!) $。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度就不展开讲了。主要来看几种常见的**多项式时间复杂度**。

### O(1)

首先必须明确一个概念，$ O(1) $ 只是常量级时间复杂度的一种表示方法，并不是单指执行了一行代码。

一般情况下，只要算法中不存在循环语句、递归语句，几遍有成千上万行的代码，其时间复杂度也是 $ O(1) $。

### O(logn) & O(nlogn)

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。

在采用大 O 标记复杂度的时候，可以忽略系数，即 $ O(Cf(n)) = O(f(n)) $。所以，$  O(log_2^n) $ 就等于 $ O(log_3^n) $。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的『底』，统一表示为 $ O(log^n) $。

$ O(n\log^n) $ 也是一种非常常见的算法时间复杂度，例如，归并排序、快速排序的时间复杂度。

### O(m+n) & O(m*n)

m 和 n 表示两个数据规模，我们无法实现评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，记为 $ O(m + n) $。乘法法则继续有效：$ T1(m) * T2(n) = O(f(m) * f(n)). $。

## 空间复杂度分析

时间复杂度的全称是**渐进时间复杂度**，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是**渐进空间复杂度（asymptotic space complexity）**，表示算法的存储空间与数据规模之间的增长关系。

我们常见的空间复杂度就是 $ O(1) O(n) O(n^2) $，像 $ O(log^n) O(n\log^n) $ 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。
